/* ccd_command.cpp
** Moptop PCO CCD library
*/
/**
 * Command wrapper around the PCO SDK library.
 * @author Chris Mottram
 * @version $Id$
 */
/**
 * This hash define is needed before including source files give us POSIX.4/IEEE1003.1b-1993 prototypes.
 */
#define _POSIX_SOURCE 1
/**
 * This hash define is needed before including source files give us POSIX.4/IEEE1003.1b-1993 prototypes.
 */
#define _POSIX_C_SOURCE 199309L

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <stdarg.h>
#include <unistd.h>
#include "log_udp.h"
#include "VersionNo.h"
#include "Cpco_com.h"
#include "Cpco_grab_usb.h"
/*
 *  PCO_errt_w.h produces loads of -Wwrite-strings warnings when compiled, so turn off this warning for
 * this source file.
 */
#pragma GCC diagnostic ignored "-Wwrite-strings"
/**
 * Define PCO_ERRT_H_CREATE_OBJECT before including PCO_errt_w.h to enable the PCO_GetErrorText
 * function to be defined.
 */
#define PCO_ERRT_H_CREATE_OBJECT
/**
 * It is required by PCO_errt_w.h to define a sprintf_s function. PCO_errt_w.h defines one in the header
 * file for Microsoft C, here we declare sprintf_s as snprintf which should work for Linux.
 */
#define sprintf_s snprintf
#include "PCO_errt_w.h"
#include "ccd_general.h"
#include "ccd_command.h"

/* data types */
/**
 * Data type holding local data to ccd_command. This consists of the following:
 * <dl>
 * <dt>Camera</dt> <dd>The instance of CPco_com used to communicate with the PCO camera. </dd>
 * <dt>Grabber</dt> <dd>The instance of CPco_grab_usb used to grab images from the PCO camera. </dd>
 * <dt>PCO_Logger</dt> <dd>The instance of CPco_Log used to receive logging from the PCO library.</dd>
 * <dt>Camera_Board</dt> <dd>The board number passed to Open_Cam.</dd>
 * <dt>Grabber_Timeout</dt> <dd>The timeout for grabbing images, in milliseconds.</dd>
 * <dt>Description</dt> <dd>The camera description returned from PCO_GetCameraDescriptor.</dd>
 * </dl>
 * @see #SETUP_ENUM_VALUE_STRING_LENGTH
 */
struct Command_Struct
{
	CPco_com *Camera;
	CPco_grab_usb* Grabber;
	CPco_Log* PCO_Logger;
	int Camera_Board;
	int Grabber_Timeout;
	SC2_Camera_Description_Response Description;
};

/* internal variables */
/**
 * Revision Control System identifier.
 */
static char rcsid[] = "$Id$";
/**
 * The instance of Command_Struct that contains local data for this module. This is initialised as follows:
 * <dl>
 * <dt>Camera</dt> <dd>NULL</dd>
 * <dt>Grabber</dt> <dd>NULL</dd>
 * <dt>PCO_Logger</dt> <dd>NULL</dd>
 * <dt>Camera_Board</dt> <dd>0</dd>
 * <dt>Grabber_Timeout</dt> <dd>40000</dd> (The PCO Edge's maximum exposure length is 20s).
 * <dt>Description</dt> <dd>{}</dd>
 * </dl>
 * @see #Command_Struct
 */
static struct Command_Struct Command_Data = 
{
	NULL,NULL,NULL,0,40000,{}
};

/**
 * Variable holding error code of last operation performed.
 */
static int Command_Error_Number = 0;
/**
 * Local variable holding description of the last error that occured.
 * @see ccd_general.html#CCD_GENERAL_ERROR_STRING_LENGTH
 */
static char Command_Error_String[CCD_GENERAL_ERROR_STRING_LENGTH] = "";
/**
 * A buffer to store the error string generated by a call to Command_PCO_Get_Error_Text.
 * @see #CCD_GENERAL_ERROR_STRING_LENGTH
 */
static char Command_PCO_Error_String[CCD_GENERAL_ERROR_STRING_LENGTH] = "";

/* internal functions */
static char *Command_PCO_Get_Error_Text(DWORD pco_err);
static int Command_BCD_To_Decimal(unsigned char x);

/* --------------------------------------------------------
** External Functions
** -------------------------------------------------------- */
/**
 * Initialise the CCD library. 
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_Error_Number
 * @see #Command_Error_String
 * @see ccd_general.html#CCD_General_Log
 * @see ccd_general.html#CCD_General_Log_Format
 */
int CCD_Command_Initialise(void)
{
#if LOGGING > 0
	CCD_General_Log(LOG_VERBOSITY_TERSE,"CCD_Command_Initialise: Started.");
#endif /* LOGGING */
	Command_Error_Number = 0;
#if LOGGING > 1
	CCD_General_Log(LOG_VERBOSITY_INTERMEDIATE,"CCD_Command_Initialise: Creating CPco_com_usb instance.");
#endif /* LOGGING */
	Command_Data.Camera = new CPco_com_usb();
	if(Command_Data.Camera == NULL)
	{
		Command_Error_Number = 1;
		sprintf(Command_Error_String,"CCD_Command_Initialise:Creating CPco_com_usb instance failed.");
		return FALSE;
	}
#if LOGGING > 1
	CCD_General_Log(LOG_VERBOSITY_INTERMEDIATE,"CCD_Command_Initialise: Creating CPco_Log instance.");
#endif /* LOGGING */
	Command_Data.PCO_Logger = new CPco_Log("pco_camera_grab.log");
	if(Command_Data.PCO_Logger == NULL)
	{
		Command_Error_Number = 2;
		sprintf(Command_Error_String,"CCD_Command_Initialise:Creating CPco_Log instance failed.");
		return FALSE;
	}
#if LOGGING > 1
	CCD_General_Log(LOG_VERBOSITY_INTERMEDIATE,"CCD_Command_Initialise: Initialising CPco_Log instance.");
#endif /* LOGGING */
	Command_Data.PCO_Logger->set_logbits(0x3);
	Command_Data.Camera->SetLog(Command_Data.PCO_Logger);
#if LOGGING > 1
	CCD_General_Log(LOG_VERBOSITY_INTERMEDIATE,"CCD_Command_Initialise: Creating CPco_Log instance.");
#endif /* LOGGING */
#if LOGGING > 0
	CCD_General_Log(LOG_VERBOSITY_TERSE,"CCD_Command_Initialise: Finished.");
#endif /* LOGGING */
	return TRUE;
}

/**
 * Finalise (finish using) the CCD library. 
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_Error_Number
 * @see #Command_Error_String
 * @see ccd_general.html#CCD_General_Log_Format
 */
int CCD_Command_Finalise(void)
{
#if LOGGING > 0
	CCD_General_Log_Format(LOG_VERBOSITY_TERSE,"CCD_Command_Finalise: Started.");
#endif /* LOGGING */
	if(Command_Data.Grabber != NULL)
		delete Command_Data.Grabber;
	if(Command_Data.Camera != NULL)
		delete Command_Data.Camera;
	if(Command_Data.PCO_Logger != NULL)
		delete Command_Data.PCO_Logger;
#if LOGGING > 0
	CCD_General_Log_Format(LOG_VERBOSITY_TERSE,"CCD_Command_Finalise: Finished.");
#endif /* LOGGING */
	return TRUE;
}

/**
 * Open a connection to the PCO camera and get a camera handle.
 * <ul>
 * <li>We check the Camera CPco_com_usb instance has been created.
 * <li>We set Command_Data.Camera_Board to the board parameter.
 * <li>We call the Camera's Open_Cam method with the board parameter to open a connection to the board.
 * <li>We construct an instance of CPco_grab_usb attached to the opened camera and assign it to Command_Data.Grabber.
 * <li>We set the Grabber's log instance to Command_Data.PCO_Logger.
 * <li>We open a conenction to the grabber by calling the Grabber's Open_Grabber method with the board parameter.
 * <li>We set the Grabber's timeout to Command_Data.Grabber_Timeout.
 * <li>We get the camera's description by calling PCO_GetCameraDescriptor and store it in Command_Data.Description.
 * </ul>
 * @param board Which camera to connect to.
 * @return The routine returns TRUE on success and FALSE if it fails.
 * @see #Command_Data
 * @see #Command_Error_Number
 * @see #Command_Error_String
 * @see #Command_PCO_Get_Error_Text
 * @see ccd_general.html#CCD_GENERAL_ONE_SECOND_MS
 * @see ccd_general.html#CCD_GENERAL_ONE_MILLISECOND_NS
 * @see ccd_general.html#CCD_GENERAL_ONE_SECOND_NS
 * @see ccd_general.html#CCD_General_Log_Format
 */
int CCD_Command_Open(int board)
{
	DWORD pco_err;
	
#if LOGGING > 0
	CCD_General_Log_Format(LOG_VERBOSITY_TERSE,"CCD_Command_Open: Started for board %d.",board);
#endif /* LOGGING */
	if(Command_Data.Camera == NULL)
	{
		Command_Error_Number = 3;
		sprintf(Command_Error_String,"CCD_Command_Open:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	Command_Data.Camera_Board = board;
#if LOGGING > 0
	CCD_General_Log_Format(LOG_VERBOSITY_INTERMEDIATE,"CCD_Command_Open: Calling Open_Cam(%d).",
			       Command_Data.Camera_Board);
#endif /* LOGGING */
	pco_err = Command_Data.Camera->Open_Cam(Command_Data.Camera_Board);
	if(pco_err != PCO_NOERROR)
	{
		Command_Error_Number = 4;
		sprintf(Command_Error_String,
			"CCD_Command_Open:Camera Open_Cam(board=%d) failed with PCO error code 0x%x (%s).",
			Command_Data.Camera_Board,pco_err,Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
	/* create grabber for opened camera */
#if LOGGING > 0
	CCD_General_Log_Format(LOG_VERBOSITY_INTERMEDIATE,"CCD_Command_Open: Creating Grabber for camera.");
#endif /* LOGGING */
	Command_Data.Grabber = new CPco_grab_usb((CPco_com_usb*)(Command_Data.Camera));
	if(Command_Data.Grabber == NULL)
	{
		Command_Error_Number = 6;
		sprintf(Command_Error_String,"CCD_Command_Open:Creating CPco_grab_usb instance failed.");
		return FALSE;
	}
	Command_Data.Grabber->SetLog(Command_Data.PCO_Logger);
#if LOGGING > 0
	CCD_General_Log_Format(LOG_VERBOSITY_INTERMEDIATE,"CCD_Command_Open: Opening Grabber with board ID %d.",
			       Command_Data.Camera_Board);
#endif /* LOGGING */
	pco_err = Command_Data.Grabber->Open_Grabber(Command_Data.Camera_Board);
	if(pco_err != PCO_NOERROR)
	{
		Command_Error_Number = 64;
		sprintf(Command_Error_String,
			"CCD_Command_Open:Grabber Open_Grabber(board=%d) failed with PCO error code 0x%x (%s).",
			Command_Data.Camera_Board,pco_err,Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
	Command_Data.Grabber->Set_Grabber_Timeout(Command_Data.Grabber_Timeout);
#if LOGGING > 0
	CCD_General_Log_Format(LOG_VERBOSITY_INTERMEDIATE,"CCD_Command_Open: Getting camera description.");
#endif /* LOGGING */
	pco_err = Command_Data.Camera->PCO_GetCameraDescriptor(&(Command_Data.Description));
	if(pco_err != PCO_NOERROR)
	{
		Command_Error_Number = 25;
		sprintf(Command_Error_String,
			"CCD_Command_Open:Camera PCO_GetCameraDescriptor failed with PCO error code 0x%x (%s).",
			pco_err,Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
#if LOGGING > 0
	CCD_General_Log_Format(LOG_VERBOSITY_TERSE,"CCD_Command_Open: Finished.");
#endif /* LOGGING */
	return TRUE;
}

/**
 * Close an open connection to the camera.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_Error_Number
 * @see #Command_Error_String
 * @see ccd_general.html#CCD_General_Log_Format
 */
int CCD_Command_Close(void)
{
#if LOGGING > 0
	CCD_General_Log_Format(LOG_VERBOSITY_TERSE,"CCD_Command_Close: Started.");
#endif /* LOGGING */
	if(Command_Data.Camera == NULL)
	{
		Command_Error_Number = 5;
		sprintf(Command_Error_String,"CCD_Command_Close:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	Command_Data.Camera->Close_Cam();
#if LOGGING > 0
	CCD_General_Log_Format(LOG_VERBOSITY_TERSE,"CCD_Command_Close: Finished.");
#endif /* LOGGING */
	return TRUE;
}

/**
 * Prepare the camera to start taking data. All previous ettings are validated and the internal settings of the camera
 * updated.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_PCO_Get_Error_Text
 * @see #Command_Data
 * @see #Command_Error_Number
 * @see #Command_Error_String 
 * @see ccd_general.html#CCD_General_Log_Format
 */
int CCD_Command_Arm_Camera(void)
{
	DWORD pco_err;

#if LOGGING > 5
	CCD_General_Log(LOG_VERBOSITY_VERBOSE,"CCD_Command_Arm_Camera: Started.");
#endif /* LOGGING */
	if(Command_Data.Camera == NULL)
	{
		Command_Error_Number = 35;
		sprintf(Command_Error_String,"CCD_Command_Arm_Camera:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	pco_err = Command_Data.Camera->PCO_ArmCamera();
	if(pco_err != PCO_NOERROR)
	{
		Command_Error_Number = 36;
		sprintf(Command_Error_String,"CCD_Command_Arm_Camera:"
			"Camera PCO_ArmCamera failed with PCO error code 0x%x (%s).",pco_err,
			Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
#if LOGGING > 5
	CCD_General_Log(LOG_VERBOSITY_VERBOSE,"CCD_Command_Arm_Camera: Finished.");
#endif /* LOGGING */
	return TRUE;
}

/**
 * Prepare the camera to start taking data. All previous ettings are validated and the internal settings of the camera
 * updated.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_Error_Number
 * @see #Command_Error_String 
 * @see #Command_PCO_Get_Error_Text
 * @see ccd_general.html#CCD_General_Log_Format
 */
int CCD_Command_Grabber_Post_Arm(void)
{
	DWORD pco_err;

#if LOGGING > 5
	CCD_General_Log(LOG_VERBOSITY_VERBOSE,"CCD_Command_Grabber_Post_Arm: Started.");
#endif /* LOGGING */
	if(Command_Data.Grabber == NULL)
	{
		Command_Error_Number = 37;
		sprintf(Command_Error_String,
			"CCD_Command_Grabber_Post_Arm:Grabber CPco_grab_usb instance not created.");
		return FALSE;
	}
	pco_err = Command_Data.Grabber->PostArm();
	if(pco_err != PCO_NOERROR)
	{
		Command_Error_Number = 38;
		sprintf(Command_Error_String,"CCD_Command_Grabber_Post_Arm:"
			"Grabber PostArm failed with PCO error code 0x%x (%s).",pco_err,
			Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
#if LOGGING > 5
	CCD_General_Log(LOG_VERBOSITY_VERBOSE,"CCD_Command_Grabber_Post_Arm: Finished.");
#endif /* LOGGING */
	return TRUE;
}

/**
 * Set the camera's time to the current time.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_Error_Number
 * @see #Command_Error_String 
 * @see #Command_PCO_Get_Error_Text
 * @see ccd_general.html#CCD_General_Log
 */
int CCD_Command_Set_Camera_To_Current_Time(void)
{
	DWORD pco_err;

#if LOGGING > 9
	CCD_General_Log(LOG_VERBOSITY_VERY_VERBOSE,"CCD_Command_Set_Camera_To_Current_Time: Started.");
#endif /* LOGGING */
	if(Command_Data.Camera == NULL)
	{
		Command_Error_Number = 7;
		sprintf(Command_Error_String,
			"CCD_Command_Set_Camera_To_Current_Time:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	pco_err = Command_Data.Camera->PCO_SetCameraToCurrentTime();
	if(pco_err != PCO_NOERROR)
	{
		Command_Error_Number = 13;
		sprintf(Command_Error_String,"CCD_Command_Set_Camera_To_Current_Time:"
			"Camera PCO_SetCameraToCurrentTime failed with PCO error code 0x%x (%s).",pco_err,
			Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
#if LOGGING > 5
	CCD_General_Log(LOG_VERBOSITY_VERY_VERBOSE,"CCD_Command_Set_Camera_To_Current_Time: Finished.");
#endif /* LOGGING */
	return TRUE;
}

/**
 * Set the camera's recording state to either TRUE (1) or FALSE (0). This allows the camera to start
 * collecting data (exposures).
 * @param rec_state An integer/boolean, set to TRUE (1) to start recording data and FALSE (0) to stop recording data.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_Error_Number
 * @see #Command_Error_String 
 * @see #Command_PCO_Get_Error_Text
 * @see ccd_general.html#CCD_General_Log_Format
 */
int CCD_Command_Set_Recording_State(int rec_state)
{
	DWORD pco_err;

#if LOGGING > 5
	CCD_General_Log_Format(LOG_VERBOSITY_INTERMEDIATE,"CCD_Command_Set_Recording_State(%d): Started.",rec_state);
#endif /* LOGGING */
	if(!CCD_GENERAL_IS_BOOLEAN(rec_state))
	{
		Command_Error_Number = 10;
		sprintf(Command_Error_String,
			"CCD_Command_Set_Recording_State:Illegal value for rec_state parameter (%d).",rec_state);
		return FALSE;
	}
	if(Command_Data.Camera == NULL)
	{
		Command_Error_Number = 11;
		sprintf(Command_Error_String,
			"CCD_Command_Set_Recording_State:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	pco_err = Command_Data.Camera->PCO_SetRecordingState(rec_state);
	if(pco_err != PCO_NOERROR)
	{
		Command_Error_Number = 12;
		sprintf(Command_Error_String,"CCD_Command_Set_Recording_State:"
			"Camera PCO_SetRecordingState(%d) failed with PCO error code 0x%x (%s).",
			rec_state,pco_err,Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
#if LOGGING > 5
	CCD_General_Log(LOG_VERBOSITY_VERY_VERBOSE,"CCD_Command_Set_Recording_State: Finished.");
#endif /* LOGGING */
	return TRUE;
}

/**
 * Reset the cameras settings to a known (default) state.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_Error_Number
 * @see #Command_Error_String 
 * @see #Command_PCO_Get_Error_Text
 * @see ccd_general.html#CCD_General_Log
 */
int CCD_Command_Reset_Settings(void)
{
	DWORD pco_err;

#if LOGGING > 9
	CCD_General_Log(LOG_VERBOSITY_VERBOSE,"CCD_Command_Reset_Settings: Started.");
#endif /* LOGGING */
	if(Command_Data.Camera == NULL)
	{
		Command_Error_Number = 14;
		sprintf(Command_Error_String,"CCD_Command_Reset_Settings:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	pco_err = Command_Data.Camera->PCO_ResetSettingsToDefault();
	if(pco_err != PCO_NOERROR)
	{
		Command_Error_Number = 15;
		sprintf(Command_Error_String,"CCD_Command_Reset_Settings:"
			"Camera PCO_ResetSettingsToDefault failed with PCO error code 0x%x (%s).",pco_err,
			Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
#if LOGGING > 5
	CCD_General_Log(LOG_VERBOSITY_VERBOSE,"CCD_Command_Reset_Settings: Finished.");
#endif /* LOGGING */
	return TRUE;
}

/**
 * Set how the camera records timestamps. 
 * @param mode An integer: 0x0 (off), 0x1 (binary), 0x2 (binary+ASCII), 0x3 (ASCII).
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_Error_Number
 * @see #Command_Error_String 
 * @see #Command_PCO_Get_Error_Text
 * @see ccd_general.html#CCD_General_Log_Format
 */
int CCD_Command_Set_Timestamp_Mode(int mode)
{
	DWORD pco_err;

#if LOGGING > 5
	CCD_General_Log_Format(LOG_VERBOSITY_VERBOSE,"CCD_Command_Set_Timestamp_Mode(%d): Started.",mode);
#endif /* LOGGING */
	if((mode < 0)||(mode > 3))
	{
		Command_Error_Number = 16;
		sprintf(Command_Error_String,
			"CCD_Command_Set_Timestamp_Mode:Illegal value for mode parameter (%d).",mode);
		return FALSE;
	}
	if(Command_Data.Camera == NULL)
	{
		Command_Error_Number = 17;
		sprintf(Command_Error_String,
			"CCD_Command_Set_Timestamp_Mode:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	pco_err = Command_Data.Camera->PCO_SetTimestampMode(mode);
	if(pco_err != PCO_NOERROR)
	{
		Command_Error_Number = 18;
		sprintf(Command_Error_String,"CCD_Command_Set_Timestamp_Mode:"
			"Camera PCO_SetTimestampMode(%d) failed with PCO error code 0x%x (%s).",
			mode,pco_err,Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
#if LOGGING > 5
	CCD_General_Log(LOG_VERBOSITY_VERBOSE,"CCD_Command_Set_Timestamp_Mode: Finished.");
#endif /* LOGGING */
	return TRUE;
}

/**
 * Set the units used for delays and exposures.
 * @param delay_timebase A CCD_COMMAND_TIMEBASE enumeration , used to set the units used for delays.
 * @param exposure_timebase A CCD_COMMAND_TIMEBASE enumeration, used to set the units used for exposures.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #CCD_COMMAND_TIMEBASE
 * @see #Command_Data
 * @see #Command_Error_Number
 * @see #Command_Error_String 
 * @see #Command_PCO_Get_Error_Text
 * @see ccd_general.html#CCD_General_Log_Format
 */
int CCD_Command_Set_Timebase(enum CCD_COMMAND_TIMEBASE delay_timebase,enum CCD_COMMAND_TIMEBASE exposure_timebase)
{
	WORD exp_timebase,del_timebase;
	DWORD pco_err;

#if LOGGING > 5
	CCD_General_Log_Format(LOG_VERBOSITY_VERBOSE,"CCD_Command_Set_Timebase(delay=%d,exposure=%d): Started.",
			       delay_timebase,exposure_timebase);
#endif /* LOGGING */
	if((delay_timebase < 0)||(delay_timebase > 2))
	{
		Command_Error_Number = 19;
		sprintf(Command_Error_String,
			"CCD_Command_Set_Timebase:Illegal value for delay_timebase parameter (%d).",delay_timebase);
		return FALSE;
	}
	if((exposure_timebase < 0)||(exposure_timebase > 2))
	{
		Command_Error_Number = 20;
		sprintf(Command_Error_String,
			"CCD_Command_Set_Timebase:Illegal value for exposure_timebase parameter (%d).",
			exposure_timebase);
		return FALSE;
	}
	if(Command_Data.Camera == NULL)
	{
		Command_Error_Number = 21;
		sprintf(Command_Error_String,
			"CCD_Command_Set_Timebase:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	del_timebase = delay_timebase;
	exp_timebase = exposure_timebase;
	pco_err = Command_Data.Camera->PCO_SetTimebase(del_timebase,exp_timebase);
	if(pco_err != PCO_NOERROR)
	{
		Command_Error_Number = 22;
		sprintf(Command_Error_String,"CCD_Command_Set_Timebase:"
			"Camera PCO_SetTimebase(%d,%d) failed with PCO error code 0x%x (%s).",
			del_timebase,exp_timebase,pco_err,Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
#if LOGGING > 5
	CCD_General_Log(LOG_VERBOSITY_VERBOSE,"CCD_Command_Set_Timebase: Finished.");
#endif /* LOGGING */
	return TRUE;
}

/**
 * Set the delay and exposure time.
 * @param delay_time An integer, used to set the delay, in units previously specified by CCD_Command_Set_Timebase.
 * @param exposure_time An integer, used to set the exposure length, 
 *        in units previously specified by CCD_Command_Set_Timebase.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_Error_Number
 * @see #Command_Error_String
 * @see #CCD_Command_Set_Timebase
 * @see #Command_PCO_Get_Error_Text
 * @see ccd_general.html#CCD_General_Log_Format
 */
int CCD_Command_Set_Delay_Exposure_Time(int delay_time,int exposure_time)
{
	DWORD exp_time_dw,delay_time_dw;
	DWORD pco_err;

#if LOGGING > 5
	CCD_General_Log_Format(LOG_VERBOSITY_INTERMEDIATE,
			       "CCD_Command_Set_Delay_Exposure_Time(delay=%d,exposure=%d): Started.",
			       delay_time,exposure_time);
#endif /* LOGGING */
	if(Command_Data.Camera == NULL)
	{
		Command_Error_Number = 23;
		sprintf(Command_Error_String,
			"CCD_Command_Set_Delay_Exposure_Time:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	delay_time_dw = delay_time;
	exp_time_dw = exposure_time;
	pco_err = Command_Data.Camera->PCO_SetDelayExposure(delay_time_dw,exp_time_dw);
	if(pco_err != PCO_NOERROR)
	{
		Command_Error_Number = 24;
		sprintf(Command_Error_String,"CCD_Command_Set_Delay_Exposure_Time:"
			"Camera PCO_SetDelayExposure(%d,%d) failed with PCO error code 0x%x (%s).",
			delay_time_dw,exp_time_dw,pco_err,Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
#if LOGGING > 5
	CCD_General_Log(LOG_VERBOSITY_INTERMEDIATE,"CCD_Command_Set_Delay_Exposure_Time: Finished.");
#endif /* LOGGING */
	return TRUE;
}

/**
 * Set the number of analogue to digital converters used.
 * @param num_adcs An integer: either 0x1 or 0x2, the number of ADCs to use. 2 is faster, 1 is more linear.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_Error_Number
 * @see #Command_Error_String 
 * @see #Command_PCO_Get_Error_Text
 * @see ccd_general.html#CCD_General_Log_Format
 */
int CCD_Command_Set_ADC_Operation(int num_adcs)
{
	DWORD pco_err;

#if LOGGING > 5
	CCD_General_Log_Format(LOG_VERBOSITY_VERBOSE,"CCD_Command_Set_ADC_Operation(%d): Started.",num_adcs);
#endif /* LOGGING */
	if((num_adcs < 1)||(num_adcs > 2))
	{
		Command_Error_Number = 26;
		sprintf(Command_Error_String,
			"CCD_Command_Set_ADC_Operation:Illegal value for num_adcs parameter (%d).",num_adcs);
		return FALSE;
	}
	if(Command_Data.Camera == NULL)
	{
		Command_Error_Number = 27;
		sprintf(Command_Error_String,
			"CCD_Command_Set_ADC_Operation:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	pco_err = Command_Data.Camera->PCO_SetADCOperation(num_adcs);
	if(pco_err != PCO_NOERROR)
	{
		Command_Error_Number = 28;
		sprintf(Command_Error_String,"CCD_Command_Set_ADC_Operation:"
			"Camera PCO_SetADCOperation(%d) failed with PCO error code 0x%x (%s).",
			num_adcs,pco_err,Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
#if LOGGING > 5
	CCD_General_Log(LOG_VERBOSITY_VERBOSE,"CCD_Command_Set_ADC_Operation: Finished.");
#endif /* LOGGING */
	return TRUE;
}

/**
 * Set the bit alignment used for the output image data.
 * @param bit_alignment An integer: 0x0 (MSB) or 0x1 (LSB).
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_Error_Number
 * @see #Command_Error_String 
 * @see #Command_PCO_Get_Error_Text
 * @see ccd_general.html#CCD_General_Log_Format
 */
int CCD_Command_Set_Bit_Alignment(int bit_alignment)
{
	DWORD pco_err;

#if LOGGING > 5
	CCD_General_Log_Format(LOG_VERBOSITY_VERBOSE,"CCD_Command_Set_Bit_Alignment(%d): Started.",bit_alignment);
#endif /* LOGGING */
	if(Command_Data.Camera == NULL)
	{
		Command_Error_Number = 31;
		sprintf(Command_Error_String,
			"CCD_Command_Set_Bit_Alignment:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	pco_err = Command_Data.Camera->PCO_SetBitAlignment(bit_alignment);
	if(pco_err != PCO_NOERROR)
	{
		Command_Error_Number = 32;
		sprintf(Command_Error_String,"CCD_Command_Set_Bit_Alignment:"
			"Camera PCO_SetBitAlignment(%d) failed with PCO error code 0x%x (%s).",
			bit_alignment,pco_err,Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
#if LOGGING > 5
	CCD_General_Log(LOG_VERBOSITY_VERBOSE,"CCD_Command_Set_Bit_Alignment: Finished.");
#endif /* LOGGING */
	return TRUE;
}

/**
 * Set what image corrects the camera performs.
 * @param mode An integer: 0x0000 (off), 0x0001 (noise filter on), 0x0101 (noise filter on + hot pixel correction).
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_Error_Number
 * @see #Command_Error_String 
 * @see #Command_PCO_Get_Error_Text
 * @see ccd_general.html#CCD_General_Log_Format
 */
int CCD_Command_Set_Noise_Filter_Mode(int mode)
{
	DWORD pco_err;

#if LOGGING > 5
	CCD_General_Log_Format(LOG_VERBOSITY_VERBOSE,"CCD_Command_Set_Noise_Filter_Mode(%d): Started.",mode);
#endif /* LOGGING */
	if(Command_Data.Camera == NULL)
	{
		Command_Error_Number = 33;
		sprintf(Command_Error_String,
			"CCD_Command_Set_Noise_Filter_Mode:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	pco_err = Command_Data.Camera->PCO_SetNoiseFilterMode(mode);
	if(pco_err != PCO_NOERROR)
	{
		Command_Error_Number = 34;
		sprintf(Command_Error_String,"CCD_Command_Set_Noise_Filter_Mode:"
			"Camera PCO_SetNoiseFilterMode(%d) failed with PCO error code 0x%x (%s).",mode,pco_err,
			Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
#if LOGGING > 5
	CCD_General_Log(LOG_VERBOSITY_VERBOSE,"CCD_Command_Set_Noise_Filter_Mode: Finished.");
#endif /* LOGGING */
	return TRUE;
}

/**
 * Set how camera exposures are triggered
 * @param mode An enum of type CCD_COMMAND_TRIGGER_MODE. Used to select external or internal trigger modes.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #CCD_COMMAND_TRIGGER_MODE
 * @see #Command_Data
 * @see #Command_Error_Number
 * @see #Command_Error_String 
 * @see #Command_PCO_Get_Error_Text
 * @see ccd_general.html#CCD_General_Log_Format
 */
int CCD_Command_Set_Trigger_Mode(enum CCD_COMMAND_TRIGGER_MODE mode)
{
	DWORD pco_err;

#if LOGGING > 5
	CCD_General_Log_Format(LOG_VERBOSITY_VERBOSE,"CCD_Command_Set_Trigger_Mode(%d): Started.",mode);
#endif /* LOGGING */
	if(Command_Data.Camera == NULL)
	{
		Command_Error_Number = 39;
		sprintf(Command_Error_String,
			"CCD_Command_Set_Trigger_Mode:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	pco_err = Command_Data.Camera->PCO_SetTriggerMode(mode);
	if(pco_err != PCO_NOERROR)
	{
		Command_Error_Number = 40;
		sprintf(Command_Error_String,"CCD_Command_Set_Trigger_Mode:"
			"Camera PCO_SetTriggerMode(%d) failed with PCO error code 0x%x (%s).",mode,pco_err,
			Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
#if LOGGING > 5
	CCD_General_Log(LOG_VERBOSITY_VERBOSE,"CCD_Command_Set_Trigger_Mode: Finished.");
#endif /* LOGGING */
	return TRUE;
}

/**
 * Set the camera binning.
 * @param bin_x An integer, the horizontal binning.
 * @param bin_y An integer, the vertical binning.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_Error_Number
 * @see #Command_Error_String 
 * @see #Command_PCO_Get_Error_Text
 * @see ccd_general.html#CCD_General_Log_Format
 */
int CCD_Command_Set_Binning(int bin_x,int bin_y)
{
	DWORD pco_err;

#if LOGGING > 5
	CCD_General_Log_Format(LOG_VERBOSITY_VERBOSE,"CCD_Command_Set_Binning(%d,%d): Started.",bin_x,bin_y);
#endif /* LOGGING */
	if(Command_Data.Camera == NULL)
	{
		Command_Error_Number = 41;
		sprintf(Command_Error_String,
			"CCD_Command_Set_Binning:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	pco_err = Command_Data.Camera->PCO_SetBinning(bin_x,bin_y);
	if(pco_err != PCO_NOERROR)
	{
		Command_Error_Number = 42;
		sprintf(Command_Error_String,"CCD_Command_Set_Binning:"
			"Camera PCO_SetBinning(%d,%d) failed with PCO error code 0x%x (%s).",bin_x,bin_y,pco_err,
			Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
#if LOGGING > 5
	CCD_General_Log(LOG_VERBOSITY_VERBOSE,"CCD_Command_Set_Binning: Finished.");
#endif /* LOGGING */
	return TRUE;
}

/**
 * Get the current 'region of interest', given the current binning settings. This is the area of the detector
 * to read out, in binned pixels.
 * @param start_x The address of an integer to store the first pixel in x on the detector to read out.
 * @param start_y The address of an integer to store the first pixel in y on the detector to read out.
 * @param end_x The address of an integer to store the last pixel in x on the detector to read out.
 * @param end_y The address of an integer to store the last pixel in y on the detector to read out.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_Error_Number
 * @see #Command_Error_String 
 * @see #Command_PCO_Get_Error_Text
 * @see ccd_general.html#CCD_General_Log
 * @see ccd_general.html#CCD_General_Log_Format
 */
int CCD_Command_Set_ROI(int start_x,int start_y,int end_x,int end_y)
{
	DWORD pco_err;
	WORD start_x_w,start_y_w,end_x_w,end_y_w;
	
#if LOGGING > 5
	CCD_General_Log_Format(LOG_VERBOSITY_INTERMEDIATE,"CCD_Command_Set_ROI(%d,%d,%d,%d): Started.",
			       start_x,start_y,end_x,end_y);
#endif /* LOGGING */
	/* check camera instance has been created, if so open should have been called,
	** and the Description field retrieved from the camera head. */
	if(Command_Data.Camera == NULL)
	{
		Command_Error_Number = 79;
		sprintf(Command_Error_String,"CCD_Command_Set_ROI:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	start_x_w = start_x;
	start_y_w = start_y;
	end_x_w = end_x;
	end_y_w = end_y;
	pco_err = Command_Data.Camera->PCO_SetROI(start_x_w,start_y_w,end_x_w,end_y_w);
	if(pco_err != PCO_NOERROR)
	{
		Command_Error_Number = 80;
		sprintf(Command_Error_String,"CCD_Command_Set_ROI:PCO_SetROI(%d,%d,%d,%d) failed(0x%x) (%s).",
			start_x_w,start_y_w,end_x_w,end_y_w,pco_err,Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
#if LOGGING > 5
	CCD_General_Log(LOG_VERBOSITY_INTERMEDIATE,"CCD_Command_Set_ROI Finished.");
#endif /* LOGGING */
	return TRUE;
}

/**
 * Get the current 'region of interest', given the current binning settings. This is the area of the detector
 * to read out, in binned pixels.
 * @param start_x The address of an integer to store the first pixel in x on the detector to read out.
 * @param start_y The address of an integer to store the first pixel in y on the detector to read out.
 * @param end_x The address of an integer to store the last pixel in x on the detector to read out.
 * @param end_y The address of an integer to store the last pixel in y on the detector to read out.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_Error_Number
 * @see #Command_Error_String 
 * @see #Command_PCO_Get_Error_Text
 * @see ccd_general.html#CCD_General_Log
 * @see ccd_general.html#CCD_General_Log_Format
 */
int CCD_Command_Set_Cooling_Setpoint_Temperature(int temperature)
{
	DWORD pco_err;
	SHORT temperature_s;
	
#if LOGGING > 5
	CCD_General_Log_Format(LOG_VERBOSITY_INTERMEDIATE,"CCD_Command_Set_Cooling_Setpoint_Temperature(%d): Started.",
			       temperature);
#endif /* LOGGING */
	/* check camera instance has been created, if so open should have been called,
	** and the Description field retrieved from the camera head. */
	if(Command_Data.Camera == NULL)
	{
		Command_Error_Number = 81;
		sprintf(Command_Error_String,
			"CCD_Command_Set_Cooling_Setpoint_Temperature:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	temperature_s = temperature;
	pco_err = Command_Data.Camera->PCO_SetCoolingSetpointTemperature(temperature_s);
	if(pco_err != PCO_NOERROR)
	{
		Command_Error_Number = 82;
		sprintf(Command_Error_String,"CCD_Command_Set_Cooling_Setpoint_Temperature:"
			"PCO_SetCoolingSetpointTemperature(%d) failed(0x%x) (%s).",
			temperature_s,pco_err,Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
#if LOGGING > 5
	CCD_General_Log(LOG_VERBOSITY_INTERMEDIATE,"CCD_Command_Set_Cooling_Setpoint_Temperature Finished.");
#endif /* LOGGING */
	return TRUE;
}

/**
 * Call the Grabber to acquire 1 frame from the camera, and place the data into the passed in image buffer.
 * @param image_buffer The address of some allocated memory to hold the read out image.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_Error_Number
 * @see #Command_Error_String 
 * @see #Command_PCO_Get_Error_Text
 * @see ccd_general.html#CCD_General_Log
 * @see ccd_general.html#CCD_General_Log_Format
 */
int CCD_Command_Grabber_Acquire_Image_Async_Wait(void *image_buffer)
{
	DWORD pco_err;

#if LOGGING > 5
	CCD_General_Log(LOG_VERBOSITY_VERBOSE,"CCD_Command_Grabber_Acquire_Image_Async_Wait: Started.");
#endif /* LOGGING */
	if(Command_Data.Grabber == NULL)
	{
		Command_Error_Number = 58;
		sprintf(Command_Error_String,
			"CCD_Command_Grabber_Acquire_Image_Async_Wait:Grabber CPco_grab_usb instance not created.");
		return FALSE;
	}
	pco_err = Command_Data.Grabber->Acquire_Image_Async_wait(image_buffer);
	if(pco_err != PCO_NOERROR)
	{
		Command_Error_Number = 59;
		sprintf(Command_Error_String,"CCD_Command_Grabber_Acquire_Image_Async_Wait:"
			"Grabber Acquire_Image_Async_wait(%p) failed with PCO error code 0x%x (%s).",image_buffer,
			pco_err,Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
#if LOGGING > 5
	CCD_General_Log(LOG_VERBOSITY_VERBOSE,"CCD_Command_Grabber_Acquire_Image_Async_Wait: Finished.");
#endif /* LOGGING */
	return TRUE;	
}

/**
 * Call the Grabber to acquire 1 frame from the camera, and place the data into the passed in image buffer.
 * @param image_buffer The address of some allocated memory to hold the read out image.
 * @param timeout The time to wait for the image to be read out, before timing out, in milliseconds.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_Error_Number
 * @see #Command_Error_String 
 * @see #Command_PCO_Get_Error_Text
 * @see ccd_general.html#CCD_General_Log
 * @see ccd_general.html#CCD_General_Log_Format
 */
int CCD_Command_Grabber_Acquire_Image_Async_Wait_Timeout(void *image_buffer,int timeout_ms)
{
	DWORD pco_err;

#if LOGGING > 5
	CCD_General_Log_Format(LOG_VERBOSITY_VERBOSE,"CCD_Command_Grabber_Acquire_Image_Async_Wait_Timeout:"
			       "Started with timeout %d ms.",timeout_ms);
#endif /* LOGGING */
	if(Command_Data.Grabber == NULL)
	{
		Command_Error_Number = 92;
		sprintf(Command_Error_String,"CCD_Command_Grabber_Acquire_Image_Async_Wait_Timeout:"
			"Grabber CPco_grab_usb instance not created.");
		return FALSE;
	}
	pco_err = Command_Data.Grabber->Acquire_Image_Async_wait(image_buffer,timeout_ms);
	if(pco_err != PCO_NOERROR)
	{
		Command_Error_Number = 93;
		sprintf(Command_Error_String,"CCD_Command_Grabber_Acquire_Image_Async_Wait_Timeout:"
			"Grabber Acquire_Image_Async_wait(%p,%d) failed with PCO error code 0x%x (%s).",image_buffer,
			timeout_ms,pco_err,Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
#if LOGGING > 5
	CCD_General_Log(LOG_VERBOSITY_VERBOSE,"CCD_Command_Grabber_Acquire_Image_Async_Wait_Timeout: Finished.");
#endif /* LOGGING */
	return TRUE;
}

/**
 * Get the camera/sensor/psu temperatures from the camera.
 * @param valid_sensor_temp The address of an integer, on a successful return from this function this will contain
 *        TRUE if a valid sensor temperature was read, and FALSE if it was not read. This address can be NULL
 *        if the sensor temperature is not required.
 * @param sensor_temp The address of a double, on a successful return from this function this will contain
 *        the sensor temperature in degrees Centigrade if it was read successfully. This address can be NULL
 *        if the sensor temperature is not required.
 * @param camera_temp The address of an integer, on a successful return from this function this will contain
 *        the camera temperature in degrees Centigrade. This address can be NULL
 *        if the camera temperature is not required.
 * @param valid_psu_temp The address of an integer, on a successful return from this function this will contain
 *        TRUE if a valid PSU temperature was read, and FALSE if it was not read. This address can be NULL
 *        if the PSU temperature is not required.
 * @param psu_temp The address of an integer, on a successful return from this function this will contain
 *        the PSU temperature in degrees Centigrade. This address can be NULL
 *        if the PSU temperature is not required.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_Error_Number
 * @see #Command_Error_String 
 * @see #Command_PCO_Get_Error_Text
 * @see ccd_general.html#CCD_General_Log
 */
int CCD_Command_Get_Temperature(int *valid_sensor_temp,double *sensor_temp,int *camera_temp,
				int *valid_psu_temp,int *psu_temp)
{
	DWORD pco_err;
	SHORT ccd_temp_s,cam_temp_s,psu_temp_s;
	
#if LOGGING > 5
	CCD_General_Log(LOG_VERBOSITY_INTERMEDIATE,"CCD_Command_Get_Temperature: Started.");
#endif /* LOGGING */
	if(Command_Data.Camera == NULL)
	{
		Command_Error_Number = 8;
		sprintf(Command_Error_String,
			"CCD_Command_Get_Temperature:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	pco_err = Command_Data.Camera->PCO_GetTemperature(&ccd_temp_s,&cam_temp_s,&psu_temp_s);
	if(pco_err != PCO_NOERROR)
	{
		Command_Error_Number = 9;
		sprintf(Command_Error_String,
			"CCD_Command_Get_Temperature:PCO_GetTemperature failed(0x%x) (%s).",pco_err,
			Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
	/* PCO_GetTemperature returns:
	** A short for the CCD temperature in tenths of degree centigrade, 
	**          which is (SHORT)(-32768) when reading the temperature fails.
	** A short for the camera temperature in degrees centigrade.
	** A short for the power supply temperature in degrees centigrade, which id 0 when the sensor does not exist.
	*/
	if((valid_sensor_temp != NULL)&&(sensor_temp != NULL))
	{
		if(ccd_temp_s != (SHORT)(-32768))
		{
			(*valid_sensor_temp) = TRUE;
			(*sensor_temp) = ((double)ccd_temp_s)/10.0;
		}
		else
		{
			(*valid_sensor_temp) = FALSE;
			(*sensor_temp) = 0.0;
		}
	}
	if(camera_temp != NULL)
	{
		(*camera_temp) = (int)cam_temp_s;
	}
	if((valid_psu_temp != NULL)&&(psu_temp != NULL))
	{
		if(psu_temp_s != (SHORT)(0x000))
		{
			(*valid_psu_temp) = TRUE;
			(*psu_temp) = (int)psu_temp_s;
		}
		else
		{
			(*valid_psu_temp) = FALSE;
			(*psu_temp) = 0;
		}
	}
	
#if LOGGING > 5
	CCD_General_Log(LOG_VERBOSITY_INTERMEDIATE,"CCD_Command_Get_Temperature: Finished.");
#endif /* LOGGING */
	return TRUE;
}

/**
 * Get the number of analogue to digital convertors inside the camera, as returned from it's description
 * (retrieved from the camera head when opening a connection to the camera, and stored in Command_Data.Description).
 * @param adc_count The address of an integer to store the numbers of analogue to digital convertors inside the camera.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_Error_Number
 * @see #Command_Error_String 
 * @see ccd_general.html#CCD_General_Log
 * @see ccd_general.html#CCD_General_Log_Format
 */
int CCD_Command_Description_Get_Num_ADCs(int *adc_count)
{
#if LOGGING > 5
	CCD_General_Log(LOG_VERBOSITY_INTERMEDIATE,"CCD_Command_Description_Get_Num_ADCs: Started.");
#endif /* LOGGING */
	if(adc_count == NULL)
	{
		Command_Error_Number = 29;
		sprintf(Command_Error_String,
			"CCD_Command_Description_Get_Num_ADCs:adc_count was NULL.");
		return FALSE;
	}
	/* check camera instance has been created, if so open should have been called,
	** and the Description field retrieved from the camera head. */
	if(Command_Data.Camera == NULL)
	{
		Command_Error_Number = 30;
		sprintf(Command_Error_String,
			"CCD_Command_Description_Get_Num_ADCs:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	(*adc_count) = Command_Data.Description.wNumADCsDESC;
#if LOGGING > 5
	CCD_General_Log_Format(LOG_VERBOSITY_INTERMEDIATE,"CCD_Command_Description_Get_Num_ADCs returned %d ADCs.",
			       (*adc_count));
#endif /* LOGGING */
	return TRUE;
}

/**
 * Get the minimum exposure length of the camera, as returned from it's description
 * (retrieved from the camera head when opening a connection to the camera, and stored in Command_Data.Description).
 * @param minimum_exposure_length_s The address of an double to store the minimum exposure length in seconds.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_Error_Number
 * @see #Command_Error_String
 * @see ccd_general.html#CCD_GENERAL_ONE_SECOND_NS
 * @see ccd_general.html#CCD_General_Log
 * @see ccd_general.html#CCD_General_Log_Format
 */
int CCD_Command_Description_Get_Exposure_Time_Min(double *minimum_exposure_length_s)
{
	DWORD min_expose_dw_ns;
	
#if LOGGING > 5
	CCD_General_Log(LOG_VERBOSITY_INTERMEDIATE,"CCD_Command_Description_Get_Exposure_Time_Min: Started.");
#endif /* LOGGING */
	if(minimum_exposure_length_s == NULL)
	{
		Command_Error_Number = 54;
		sprintf(Command_Error_String,
			"CCD_Command_Description_Get_Exposure_Time_Min:minimum_exposure_length_s was NULL.");
		return FALSE;
	}
	/* check camera instance has been created, if so open should have been called,
	** and the Description field retrieved from the camera head. */
	if(Command_Data.Camera == NULL)
	{
		Command_Error_Number = 55;
		sprintf(Command_Error_String,
			"CCD_Command_Description_Get_Exposure_Time_Min:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	min_expose_dw_ns = Command_Data.Description.dwMinExposureDESC;
	/* The minimum exposure length in the description structure is in nanoseconds, convert to seconds */
	(*minimum_exposure_length_s) = ((double)min_expose_dw_ns)/((double)CCD_GENERAL_ONE_SECOND_NS);
#if LOGGING > 5
	CCD_General_Log_Format(LOG_VERBOSITY_INTERMEDIATE,
			       "CCD_Command_Description_Get_Exposure_Time_Min returned %.2f s minimum exposure length.",
			       (*minimum_exposure_length_s));
#endif /* LOGGING */
	return TRUE;
}

/**
 * Get the maximum exposure length of the camera, as returned from it's description
 * (retrieved from the camera head when opening a connection to the camera, and stored in Command_Data.Description).
 * @param maximum_exposure_length_s The address of an double to store the maximum exposure length in seconds.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_Error_Number
 * @see #Command_Error_String
 * @see ccd_general.html#CCD_GENERAL_ONE_SECOND_MS
 * @see ccd_general.html#CCD_General_Log
 * @see ccd_general.html#CCD_General_Log_Format
 */
int CCD_Command_Description_Get_Exposure_Time_Max(double *maximum_exposure_length_s)
{
	DWORD max_expose_dw_ms;
	
#if LOGGING > 5
	CCD_General_Log(LOG_VERBOSITY_INTERMEDIATE,"CCD_Command_Description_Get_Exposure_Time_Max: Started.");
#endif /* LOGGING */
	if(maximum_exposure_length_s == NULL)
	{
		Command_Error_Number = 56;
		sprintf(Command_Error_String,
			"CCD_Command_Description_Get_Exposure_Time_Max:maximum_exposure_length_s was NULL.");
		return FALSE;
	}
	/* check camera instance has been created, if so open should have been called,
	** and the Description field retrieved from the camera head. */
	if(Command_Data.Camera == NULL)
	{
		Command_Error_Number = 57;
		sprintf(Command_Error_String,
			"CCD_Command_Description_Get_Exposure_Time_Max:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	max_expose_dw_ms = Command_Data.Description.dwMaxExposureDESC;
	/* The maximum exposure length in the description structure is in milliseconds, convert to seconds */
	(*maximum_exposure_length_s) = ((double)max_expose_dw_ms)/((double)CCD_GENERAL_ONE_SECOND_MS);
#if LOGGING > 5
	CCD_General_Log_Format(LOG_VERBOSITY_INTERMEDIATE,
			       "CCD_Command_Description_Get_Exposure_Time_Max returned %.2f s maximum exposure length.",
			       (*maximum_exposure_length_s));
#endif /* LOGGING */
	return TRUE;
}

/**
 * Get the maximum horizontal (x) size of the camera sensor (in standard mode), as returned from it's description
 * (retrieved from the camera head when opening a connection to the camera, and stored in Command_Data.Description).
 * @param max_hor_size The address of an integer to store the maximum horizontal (x) size of the sensor, in pixels.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_Error_Number
 * @see #Command_Error_String
 * @see ccd_general.html#CCD_General_Log
 * @see ccd_general.html#CCD_General_Log_Format
 */
int CCD_Command_Description_Get_Max_Horizontal_Size(int *max_hor_size)
{
#if LOGGING > 5
	CCD_General_Log(LOG_VERBOSITY_INTERMEDIATE,"CCD_Command_Description_Get_Max_Horizontal_Size: Started.");
#endif /* LOGGING */
	if(max_hor_size == NULL)
	{
		Command_Error_Number = 65;
		sprintf(Command_Error_String,
			"CCD_Command_Description_Get_Max_Horizontal_Size:max_hor_size was NULL.");
		return FALSE;
	}
	/* check camera instance has been created, if so open should have been called,
	** and the Description field retrieved from the camera head. */
	if(Command_Data.Camera == NULL)
	{
		Command_Error_Number = 66;
		sprintf(Command_Error_String,
			"CCD_Command_Description_Get_Max_Horizontal_Size:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	(*max_hor_size) = Command_Data.Description.wMaxHorzResStdDESC;
#if LOGGING > 5
	CCD_General_Log_Format(LOG_VERBOSITY_INTERMEDIATE,
			       "CCD_Command_Description_Get_Max_Horizontal_Size returned %d pixels.",(*max_hor_size));
#endif /* LOGGING */
	return TRUE;
}

/**
 * Get the maximum vertical (y) size of the camera sensor (in standard mode), as returned from it's description
 * (retrieved from the camera head when opening a connection to the camera, and stored in Command_Data.Description).
 * @param max_ver_size The address of an integer to store the maximum vertical (y) size of the sensor, in pixels.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_Error_Number
 * @see #Command_Error_String
 * @see ccd_general.html#CCD_General_Log
 * @see ccd_general.html#CCD_General_Log_Format
 */
int CCD_Command_Description_Get_Max_Vertical_Size(int *max_ver_size)
{
#if LOGGING > 5
	CCD_General_Log(LOG_VERBOSITY_INTERMEDIATE,"CCD_Command_Description_Get_Max_Vertical_Size: Started.");
#endif /* LOGGING */
	if(max_ver_size == NULL)
	{
		Command_Error_Number = 67;
		sprintf(Command_Error_String,
			"CCD_Command_Description_Get_Max_Vertical_Size:max_ver_size was NULL.");
		return FALSE;
	}
	/* check camera instance has been created, if so open should have been called,
	** and the Description field retrieved from the camera head. */
	if(Command_Data.Camera == NULL)
	{
		Command_Error_Number = 68;
		sprintf(Command_Error_String,
			"CCD_Command_Description_Get_Max_Vertical_Size:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	(*max_ver_size) = Command_Data.Description.wMaxVertResStdDESC;
#if LOGGING > 5
	CCD_General_Log_Format(LOG_VERBOSITY_INTERMEDIATE,
			       "CCD_Command_Description_Get_Max_Vertical_Size returned %d pixels.",(*max_ver_size));
#endif /* LOGGING */
	return TRUE;
}

/**
 * Get the default cooling set-point of the camera sensor, as returned from it's description
 * (retrieved from the camera head when opening a connection to the camera, and stored in Command_Data.Description).
 * @param temperature The address of an integer to store the default cooling setpoint, in degrees centigrade.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_Error_Number
 * @see #Command_Error_String
 * @see ccd_general.html#CCD_General_Log
 * @see ccd_general.html#CCD_General_Log_Format
 */
int CCD_Command_Description_Get_Default_Cooling_Setpoint(int *temperature)
{
#if LOGGING > 5
	CCD_General_Log(LOG_VERBOSITY_INTERMEDIATE,"CCD_Command_Description_Get_Default_Cooling_Setpoint: Started.");
#endif /* LOGGING */
	if(temperature == NULL)
	{
		Command_Error_Number = 83;
		sprintf(Command_Error_String,
			"CCD_Command_Description_Get_Default_Cooling_Setpoint:temperature was NULL.");
		return FALSE;
	}
	/* check camera instance has been created, if so open should have been called,
	** and the Description field retrieved from the camera head. */
	if(Command_Data.Camera == NULL)
	{
		Command_Error_Number = 84;
		sprintf(Command_Error_String,
			"CCD_Command_Description_Get_Default_Cooling_Setpoint:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	(*temperature) = Command_Data.Description.sDefaultCoolSetDESC;
#if LOGGING > 5
	CCD_General_Log_Format(LOG_VERBOSITY_INTERMEDIATE,
			       "CCD_Command_Description_Get_Default_Cooling_Setpoint returned %d C.",(*temperature));
#endif /* LOGGING */
	return TRUE;
}

/**
 * Get the minimum cooling set-point of the camera sensor, as returned from it's description
 * (retrieved from the camera head when opening a connection to the camera, and stored in Command_Data.Description).
 * @param temperature The address of an integer to store the minimum cooling setpoint, in degrees centigrade.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_Error_Number
 * @see #Command_Error_String
 * @see ccd_general.html#CCD_General_Log
 * @see ccd_general.html#CCD_General_Log_Format
 */
int CCD_Command_Description_Get_Min_Cooling_Setpoint(int *temperature)
{
#if LOGGING > 5
	CCD_General_Log(LOG_VERBOSITY_INTERMEDIATE,"CCD_Command_Description_Get_Min_Cooling_Setpoint: Started.");
#endif /* LOGGING */
	if(temperature == NULL)
	{
		Command_Error_Number = 85;
		sprintf(Command_Error_String,
			"CCD_Command_Description_Get_Min_Cooling_Setpoint:temperature was NULL.");
		return FALSE;
	}
	/* check camera instance has been created, if so open should have been called,
	** and the Description field retrieved from the camera head. */
	if(Command_Data.Camera == NULL)
	{
		Command_Error_Number = 86;
		sprintf(Command_Error_String,
			"CCD_Command_Description_Get_Min_Cooling_Setpoint:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	(*temperature) = Command_Data.Description.sMinCoolSetDESC;
#if LOGGING > 5
	CCD_General_Log_Format(LOG_VERBOSITY_INTERMEDIATE,
			       "CCD_Command_Description_Get_Min_Cooling_Setpoint returned %d C.",(*temperature));
#endif /* LOGGING */
	return TRUE;
}

/**
 * Get the maximum cooling set-point of the camera sensor, as returned from it's description
 * (retrieved from the camera head when opening a connection to the camera, and stored in Command_Data.Description).
 * @param temperature The address of an integer to store the maximum cooling setpoint, in degrees centigrade.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_Error_Number
 * @see #Command_Error_String
 * @see ccd_general.html#CCD_General_Log
 * @see ccd_general.html#CCD_General_Log_Format
 */
int CCD_Command_Description_Get_Max_Cooling_Setpoint(int *temperature)
{
#if LOGGING > 5
	CCD_General_Log(LOG_VERBOSITY_INTERMEDIATE,"CCD_Command_Description_Get_Max_Cooling_Setpoint: Started.");
#endif /* LOGGING */
	if(temperature == NULL)
	{
		Command_Error_Number = 87;
		sprintf(Command_Error_String,
			"CCD_Command_Description_Get_Max_Cooling_Setpoint:temperature was NULL.");
		return FALSE;
	}
	/* check camera instance has been created, if so open should have been called,
	** and the Description field retrieved from the camera head. */
	if(Command_Data.Camera == NULL)
	{
		Command_Error_Number = 88;
		sprintf(Command_Error_String,
			"CCD_Command_Description_Get_Max_Cooling_Setpoint:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	(*temperature) = Command_Data.Description.sMaxCoolSetDESC;
#if LOGGING > 5
	CCD_General_Log_Format(LOG_VERBOSITY_INTERMEDIATE,
			       "CCD_Command_Description_Get_Max_Cooling_Setpoint returned %d C.",(*temperature));
#endif /* LOGGING */
	return TRUE;
}

/**
 * Get the camera type and serial number of the currently connected camera.
 * @param camera_type The address of an integer to store the camera type number.
 * @param serial_number The address of an integer to store the serial number of the camera.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_Error_Number
 * @see #Command_Error_String 
 * @see #Command_PCO_Get_Error_Text
 * @see ccd_general.html#CCD_General_Log
 * @see ccd_general.html#CCD_General_Log_Format
 */
int CCD_Command_Get_Camera_Type(int *camera_type,int *serial_number)
{
	DWORD pco_err;
	DWORD serial_number_dw;
	WORD camera_type_w;
	
#if LOGGING > 5
	CCD_General_Log(LOG_VERBOSITY_INTERMEDIATE,"CCD_Command_Get_Camera_Type: Started.");
#endif /* LOGGING */
	if(camera_type == NULL)
	{
		Command_Error_Number = 69;
		sprintf(Command_Error_String,"CCD_Command_Get_Camera_Type:camera_type was NULL.");
		return FALSE;
	}
	if(serial_number == NULL)
	{
		Command_Error_Number = 70;
		sprintf(Command_Error_String,"CCD_Command_Get_Camera_Type:serial_number was NULL.");
		return FALSE;
	}
	/* check camera instance has been created, if so open should have been called,
	** and the Description field retrieved from the camera head. */
	if(Command_Data.Camera == NULL)
	{
		Command_Error_Number = 71;
		sprintf(Command_Error_String,"CCD_Command_Get_Camera_Type:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	pco_err = Command_Data.Camera->PCO_GetCameraType(&camera_type_w,&serial_number_dw);
	if(pco_err != PCO_NOERROR)
	{
		Command_Error_Number = 72;
		sprintf(Command_Error_String,"CCD_Command_Get_Camera_Type:PCO_GetCameraType failed(0x%x) (%s).",
			pco_err,Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
	(*camera_type) = camera_type_w;
	(*serial_number) = serial_number_dw;
#if LOGGING > 5
	CCD_General_Log_Format(LOG_VERBOSITY_INTERMEDIATE,
			       "CCD_Command_Get_Camera_Type returned camera type = 0x%x, serial number = %d.",
			       (*camera_type),(*serial_number));
#endif /* LOGGING */
	return TRUE;
}

/**
 * Get the current 'region of interest', given the current binning settings. This is the area of the detector
 * to read out, in binned pixels.
 * @param start_x The address of an integer to store the first pixel in x on the detector to read out.
 * @param start_y The address of an integer to store the first pixel in y on the detector to read out.
 * @param end_x The address of an integer to store the last pixel in x on the detector to read out.
 * @param end_y The address of an integer to store the last pixel in y on the detector to read out.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_Error_Number
 * @see #Command_Error_String 
 * @see #Command_PCO_Get_Error_Text
 * @see ccd_general.html#CCD_General_Log
 * @see ccd_general.html#CCD_General_Log_Format
 */
int CCD_Command_Get_ROI(int *start_x,int *start_y,int *end_x,int *end_y)
{
	DWORD pco_err;
	WORD start_x_w,start_y_w,end_x_w,end_y_w;
	
#if LOGGING > 5
	CCD_General_Log(LOG_VERBOSITY_INTERMEDIATE,"CCD_Command_Get_ROI: Started.");
#endif /* LOGGING */
	if(start_x == NULL)
	{
		Command_Error_Number = 73;
		sprintf(Command_Error_String,"CCD_Command_Get_ROI:start_x was NULL.");
		return FALSE;
	}
	if(start_y == NULL)
	{
		Command_Error_Number = 74;
		sprintf(Command_Error_String,"CCD_Command_Get_ROI:start_y was NULL.");
		return FALSE;
	}
	if(end_x == NULL)
	{
		Command_Error_Number = 75;
		sprintf(Command_Error_String,"CCD_Command_Get_ROI:end_x was NULL.");
		return FALSE;
	}
	if(end_y == NULL)
	{
		Command_Error_Number = 76;
		sprintf(Command_Error_String,"CCD_Command_Get_ROI:end_y was NULL.");
		return FALSE;
	}
	/* check camera instance has been created, if so open should have been called,
	** and the Description field retrieved from the camera head. */
	if(Command_Data.Camera == NULL)
	{
		Command_Error_Number = 77;
		sprintf(Command_Error_String,"CCD_Command_Get_ROI:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	pco_err = Command_Data.Camera->PCO_GetROI(&start_x_w,&start_y_w,&end_x_w,&end_y_w);
	if(pco_err != PCO_NOERROR)
	{
		Command_Error_Number = 78;
		sprintf(Command_Error_String,"CCD_Command_Get_ROI:PCO_GetROI failed(0x%x) (%s).",
			pco_err,Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
	(*start_x) = start_x_w;
	(*start_y) = start_y_w;
	(*end_x) = end_x_w;
	(*end_y) = end_y_w;
#if LOGGING > 5
	CCD_General_Log_Format(LOG_VERBOSITY_INTERMEDIATE,
			       "CCD_Command_Get_ROI returned start (%d,%d), end = (%d,%d).",
			       (*start_x),(*start_y),(*end_x),(*end_y));
#endif /* LOGGING */
	return TRUE;
}

/**
 * Get the actual size of the image that the camera will return, given the current binning settings.
 * @param image_width The address of an integer to store the width of the image, in pixels.
 * @param image_height The address of an integer to store height of the image, in pixels.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_Error_Number
 * @see #Command_Error_String 
 * @see #Command_PCO_Get_Error_Text
 * @see ccd_general.html#CCD_General_Log
 * @see ccd_general.html#CCD_General_Log_Format
 */
int CCD_Command_Get_Actual_Size(int *image_width,int *image_height)
{
	DWORD pco_err;
	DWORD image_width_w,image_height_w;
	
#if LOGGING > 5
	CCD_General_Log(LOG_VERBOSITY_INTERMEDIATE,"CCD_Command_Get_Actual_Size: Started.");
#endif /* LOGGING */
	if(image_width == NULL)
	{
		Command_Error_Number = 43;
		sprintf(Command_Error_String,"CCD_Command_Get_Actual_Size:image_width was NULL.");
		return FALSE;
	}
	if(image_height == NULL)
	{
		Command_Error_Number = 44;
		sprintf(Command_Error_String,"CCD_Command_Get_Actual_Size:image_height was NULL.");
		return FALSE;
	}
	/* check camera instance has been created, if so open should have been called,
	** and the Description field retrieved from the camera head. */
	if(Command_Data.Camera == NULL)
	{
		Command_Error_Number = 45;
		sprintf(Command_Error_String,"CCD_Command_Get_Actual_Size:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	pco_err = Command_Data.Camera->PCO_GetActualSize(&image_width_w,&image_height_w);
	if(pco_err != PCO_NOERROR)
	{
		Command_Error_Number = 46;
		sprintf(Command_Error_String,"CCD_Command_Get_Actual_Size:PCO_GetActualSize failed(0x%x) (%s).",
			pco_err,Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
	(*image_width) = image_width_w;
	(*image_height) = image_height_w;
#if LOGGING > 5
	CCD_General_Log_Format(LOG_VERBOSITY_INTERMEDIATE,
			       "CCD_Command_Get_Actual_Size returned width = %d pixels, height = %d pixels.",
			       (*image_width),(*image_height));
#endif /* LOGGING */
	return TRUE;
}

/**
 * Get the size of the image in bytes.
 * @param image_size The address opf an integer to return the image size, in bytes.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Error_Number
 * @see #Command_Error_String
 * @see ccd_general.html#CCD_General_Log
 * @see ccd_general.html#CCD_General_Log_Format
 */ 
int CCD_Command_Get_Image_Size_Bytes(int *image_size)
{
	int image_width,image_height;
#if LOGGING > 5
	CCD_General_Log(LOG_VERBOSITY_INTERMEDIATE,"CCD_Command_Get_Image_Size_Bytes: Started.");
#endif /* LOGGING */
	if(image_size == NULL)
	{
		Command_Error_Number = 47;
		sprintf(Command_Error_String,"CCD_Command_Get_Image_Size_Bytes:image_size was NULL.");
		return FALSE;
	}
	/* get the binned image dimensions from the camera */
	if(!CCD_Command_Get_Actual_Size(&image_width,&image_height))
		return FALSE;
	/* I think pixels are unsigned shorts, typdefed to WORD in the PCO library (defs.h) */
	(*image_size) = image_width*image_height*sizeof(WORD);
#if LOGGING > 5
	CCD_General_Log_Format(LOG_VERBOSITY_INTERMEDIATE,
			       "CCD_Command_Get_Image_Size_Bytes: Returned image size in bytes of %d.",(*image_size));
#endif /* LOGGING */
	return TRUE;
}

/**
 * Set how camera exposures are triggered
 * @param mode An enum of type CCD_COMMAND_TRIGGER_MODE. Used to select external or internal trigger modes.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #CCD_COMMAND_TRIGGER_MODE
 * @see #Command_Data
 * @see #Command_Error_Number
 * @see #Command_Error_String 
 * @see #Command_PCO_Get_Error_Text
 * @see ccd_general.html#CCD_General_Log_Format
 */
int CCD_Command_Get_Trigger_Mode(enum CCD_COMMAND_TRIGGER_MODE *mode)
{
	DWORD pco_err;
	WORD mode_w;
	
#if LOGGING > 5
	CCD_General_Log(LOG_VERBOSITY_VERBOSE,"CCD_Command_Get_Trigger_Mode: Started.");
#endif /* LOGGING */
	if(mode == NULL)
	{
		Command_Error_Number = 48;
		sprintf(Command_Error_String,"CCD_Command_Get_Trigger_Mode:mode was NULL.");
		return FALSE;
	}
	if(Command_Data.Camera == NULL)
	{
		Command_Error_Number = 49;
		sprintf(Command_Error_String,
			"CCD_Command_Get_Trigger_Mode:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	pco_err = Command_Data.Camera->PCO_GetTriggerMode(&mode_w);
	if(pco_err != PCO_NOERROR)
	{
		Command_Error_Number = 50;
		sprintf(Command_Error_String,"CCD_Command_Get_Trigger_Mode:"
			"Camera PCO_GetTriggerMode failed with PCO error code 0x%x (%s).",pco_err,
			Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
	switch(mode_w)
	{
		case 0x0: /* software/  auto */
			(*mode) = CCD_COMMAND_TRIGGER_MODE_INTERNAL;
			break;
		case 0x2: /* external exposure start & software trigger */
			(*mode) = CCD_COMMAND_TRIGGER_MODE_EXTERNAL;
			break;
		default:
			Command_Error_Number = 51;
			sprintf(Command_Error_String,"CCD_Command_Get_Trigger_Mode:"
				"Camera PCO_GetTriggerMode returned unsupported trigger mode 0x%x.",mode_w);
			
			break;
	}
#if LOGGING > 5
	CCD_General_Log_Format(LOG_VERBOSITY_VERBOSE,
			       "CCD_Command_Get_Trigger_Mode: Finished and returned trigger mode %d.",(*mode));
#endif /* LOGGING */
	return TRUE;
}

/**
 * Get the currently set delay and exposure time.
 * @param delay_time The address of an integer, to be filled in with the current delay time, 
 *                    in units previously specified by CCD_Command_Set_Timebase.
 * @param exposure_time The address of an integer, to be filled in with the current exposure length, 
 *        in units previously specified by CCD_Command_Set_Timebase.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_Error_Number
 * @see #Command_Error_String
 * @see #CCD_Command_Set_Timebase
 * @see #Command_PCO_Get_Error_Text
 * @see ccd_general.html#CCD_General_Log_Format
 */
int CCD_Command_Get_Delay_Exposure_Time(int *delay_time,int *exposure_time)
{
	DWORD exp_time_dw,delay_time_dw;
	DWORD pco_err;

#if LOGGING > 5
	CCD_General_Log(LOG_VERBOSITY_INTERMEDIATE,"CCD_Command_Get_Delay_Exposure_Time: Started.");
#endif /* LOGGING */
	if(Command_Data.Camera == NULL)
	{
		Command_Error_Number = 52;
		sprintf(Command_Error_String,
			"CCD_Command_Get_Delay_Exposure_Time:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	pco_err = Command_Data.Camera->PCO_GetDelayExposure(&delay_time_dw,&exp_time_dw);
	if(pco_err != PCO_NOERROR)
	{
		Command_Error_Number = 53;
		sprintf(Command_Error_String,"CCD_Command_Get_Delay_Exposure_Time:"
			"Camera PCO_GetDelayExposure failed with PCO error code 0x%x (%s).",pco_err,
			Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
	if(delay_time != NULL)
		(*delay_time) = delay_time_dw;
	if(exposure_time != NULL)
		(*exposure_time) = exp_time_dw;
#if LOGGING > 5
	CCD_General_Log_Format(LOG_VERBOSITY_INTERMEDIATE,
			    "CCD_Command_Get_Delay_Exposure_Time: Finished returning delay time %d, exposure time %d.",
			       delay_time_dw,exp_time_dw);
#endif /* LOGGING */
	return TRUE;
}

/**
 * Get the current cooling setpoint temperature.
 * @param temperature The address of an integer, to be filled in with the current setpoint temperature in degrees C.
 * @return The routine returns TRUE on success and FALSE if an error occurs.
 * @see #Command_Data
 * @see #Command_Error_Number
 * @see #Command_Error_String
 * @see #Command_PCO_Get_Error_Text
 * @see ccd_general.html#CCD_General_Log_Format
 */
int CCD_Command_Get_Cooling_Setpoint_Temperature(int *temperature)
{
	SHORT temperature_s;
	DWORD pco_err;

#if LOGGING > 5
	CCD_General_Log(LOG_VERBOSITY_INTERMEDIATE,"CCD_Command_Get_Cooling_Setpoint_Temperature: Started.");
#endif /* LOGGING */
	if(temperature == NULL)
	{
		Command_Error_Number = 89;
		sprintf(Command_Error_String,
			"CCD_Command_Get_Cooling_Setpoint_Temperature:temperature was NULL.");
		return FALSE;
	}
	if(Command_Data.Camera == NULL)
	{
		Command_Error_Number = 90;
		sprintf(Command_Error_String,
			"CCD_Command_Get_Cooling_Setpoint_Temperature:Camera CPco_com_usb instance not created.");
		return FALSE;
	}
	pco_err = Command_Data.Camera->PCO_GetCoolingSetpointTemperature(&temperature_s);
	if(pco_err != PCO_NOERROR)
	{
		Command_Error_Number = 91;
		sprintf(Command_Error_String,"CCD_Command_Get_Cooling_Setpoint_Temperature:"
			"Camera PCO_GetCoolingSetpointTemperature failed with PCO error code 0x%x (%s).",pco_err,
			Command_PCO_Get_Error_Text(pco_err));
		return FALSE;
	}
	(*temperature) = temperature_s;
#if LOGGING > 5
	CCD_General_Log_Format(LOG_VERBOSITY_INTERMEDIATE,"CCD_Command_Get_Cooling_Setpoint_Temperature: "
			       "Finished returning setpoint temperature %d C.",temperature_s);
#endif /* LOGGING */
	return TRUE;
}

/**
 * Get the image number from the metadata encoded in the first few bytes of the image data.
 * The algorithm is copied from the example programs. The shift is zero for 64-bit linux machines with a PCO edge head.
 * @param image_buffer A pointer to the image data read out from the camera.
 * @param image_buffer_length The length of the image buffer.
 * @param image_number The address of an integer to store the decoded image number.
 * @see #Command_Error_Number
 * @see #Command_Error_String
 * @see ccd_general.html#CCD_General_Log
 * @see ccd_general.html#CCD_General_Log_Format
 */
int CCD_Command_Get_Image_Number_From_Metadata(void *image_buffer,size_t image_buffer_length,int *image_number)
{
	unsigned short *b;
	int y,shift;
	int image_nr=0;

#if LOGGING > 5
	CCD_General_Log(LOG_VERBOSITY_VERBOSE,"CCD_Command_Get_Image_Number_From_Metadata: Started.");
#endif /* LOGGING */
	if(image_buffer == NULL)
	{
		Command_Error_Number = 60;
		sprintf(Command_Error_String,"CCD_Command_Get_Image_Number_From_Metadata:image_buffer was NULL.");
		return FALSE;
	}
	if(image_number == NULL)
	{
		Command_Error_Number = 61;
		sprintf(Command_Error_String,"CCD_Command_Get_Image_Number_From_Metadata:image_number was NULL.");
		return FALSE;
	}
	shift = 0;
	b=(unsigned short *)(image_buffer);
	y=100*100*100;
	for(;y>0;y/=100)
	{
		*b>>=shift;
		image_nr += (((*b&0x00F0)>>4)*10 + (*b&0x000F))*y;
		b++;
	}
	(*image_number) = image_nr;
#if LOGGING > 5
	CCD_General_Log_Format(LOG_VERBOSITY_VERBOSE,
			       "CCD_Command_Get_Image_Number_From_Metadata: Returned image number %d.",(*image_number));
#endif /* LOGGING */
	return TRUE;
}

/**
 * Routine to extract the timestamp from the read out image data.
 * @param image_buffer A pointer to the image data.
 * @param image_buffer_length The length of the image buffer in bytes.
 * @param camera_timestamp The address of a timespec structure. On a successful return this will be filled in
 *        with the extracted timestamp.
 * @see #Command_BCD_To_Decimal
 * @see #Command_Error_Number
 * @see #Command_Error_String
 * @see ccd_general.html#CCD_General_Log
 * @see ccd_general.html#CCD_General_Log_Format
 */
int CCD_Command_Get_Timestamp_From_Metadata(void *image_buffer,size_t image_buffer_length,
					    struct timespec *camera_timestamp)
{
	struct tm timestamp_tm;
	WORD *picbuf = NULL;
	int century,year,month,day,hour,mins,secs,csecs,ccsec;
	
#if LOGGING > 5
	CCD_General_Log(LOG_VERBOSITY_VERBOSE,"CCD_Command_Get_Timestamp_From_Metadata: Started.");
#endif /* LOGGING */
	if(image_buffer == NULL)
	{
		Command_Error_Number = 62;
		sprintf(Command_Error_String,"CCD_Command_Get_Timestamp_From_Metadata:image_buffer was NULL.");
		return FALSE;
	}
	if(camera_timestamp == NULL)
	{
		Command_Error_Number = 63;
		sprintf(Command_Error_String,"CCD_Command_Get_Timestamp_From_Metadata:camera_timestamp was NULL.");
		return FALSE;
	}
	picbuf = (WORD*)image_buffer;
	century = Command_BCD_To_Decimal(picbuf[4]);
	year = Command_BCD_To_Decimal(picbuf[5]);
	month = Command_BCD_To_Decimal(picbuf[6]);
	day = Command_BCD_To_Decimal(picbuf[7]);
	hour = Command_BCD_To_Decimal(picbuf[8]);
	mins = Command_BCD_To_Decimal(picbuf[9]);
	secs = Command_BCD_To_Decimal(picbuf[10]);
	csecs = Command_BCD_To_Decimal(picbuf[11]); /* tenths and hundredths of a second */
	ccsec = Command_BCD_To_Decimal(picbuf[12]); /* thousandths and ten thousandths of a second */
#if LOGGING > 5
	CCD_General_Log_Format(LOG_VERBOSITY_VERY_VERBOSE,
			      "CCD_Command_Get_Timestamp_From_Metadata: century = %d, year = %d, month = %d, day = %d.",
			       century,year,month,day);
	CCD_General_Log_Format(LOG_VERBOSITY_VERY_VERBOSE,
			      "CCD_Command_Get_Timestamp_From_Metadata: hour = %d, minutes = %d, seconds = %d, tenths/hundredths = %d, thousandths and ten thousandths = %d.",
			       hour,mins,secs,csecs,ccsec);
#endif /* LOGGING */
	/* setup timestamp_tm */
	timestamp_tm.tm_sec = secs;
	timestamp_tm.tm_min = mins;
	timestamp_tm.tm_hour = hour;
	timestamp_tm.tm_mday = day;
	timestamp_tm.tm_mon = month-1; /* tm_mon 0..11, month 1..12 */
	timestamp_tm.tm_year = year; /* tm_year is year - 1900 */
	if(century == 20)
		timestamp_tm.tm_year += 100; /* tm_year is year - 1900 */
	/* ignored by mktime
	timestamp_tm.tm_wday = ;
	timestamp_tm.tm_yday = ;
	*/
	timestamp_tm.tm_isdst = 0; /* no daylight saving time */
	/* convert timestamp_tm to a time_t (seconds since the epoch) and store in camera_timestamp.tv_sec */
	(*camera_timestamp).tv_sec = mktime(&timestamp_tm);
	(*camera_timestamp).tv_nsec = (csecs*10000000)+(ccsec*100000);
#if LOGGING > 5
	CCD_General_Log(LOG_VERBOSITY_VERBOSE,"CCD_Command_Get_Timestamp_From_Metadata: Finished.");
#endif /* LOGGING */
	return TRUE;
}

/**
 * Get the current value of the error number.
 * @return The current value of the error number.
 * @see #Command_Error_Number
 */
int CCD_Command_Get_Error_Number(void)
{
	return Command_Error_Number;
}

/**
 * The error routine that reports any errors occuring in a standard way.
 * @see #Command_Error_Number
 * @see #Command_Error_String
 * @see ccd_general.html#CCD_General_Get_Current_Time_String
 */
void CCD_Command_Error(void)
{
	char time_string[32];

	CCD_General_Get_Current_Time_String(time_string,32);
	/* if the error number is zero an error message has not been set up
	** This is in itself an error as we should not be calling this routine
	** without there being an error to display */
	if(Command_Error_Number == 0)
		sprintf(Command_Error_String,"Logic Error:No Error defined");
	fprintf(stderr,"%s CCD_Command:Error(%d) : %s\n",time_string,
		Command_Error_Number,Command_Error_String);
}

/**
 * The error routine that reports any errors occuring in a standard way. This routine places the
 * generated error string at the end of a passed in string argument.
 * @param error_string A string to put the generated error in. This string should be initialised before
 * being passed to this routine. The routine will try to concatenate it's error string onto the end
 * of any string already in existance.
 * @see #Command_Error_Number
 * @see #Command_Error_String
 * @see ccd_general.html#CCD_General_Get_Current_Time_String
 */
void CCD_Command_Error_String(char *error_string)
{
	char time_string[32];

	CCD_General_Get_Current_Time_String(time_string,32);
	/* if the error number is zero an error message has not been set up
	** This is in itself an error as we should not be calling this routine
	** without there being an error to display */
	if(Command_Error_Number == 0)
		sprintf(Command_Error_String,"Logic Error:No Error defined");
	sprintf(error_string+strlen(error_string),"%s CCD_Command:Error(%d) : %s\n",time_string,
		Command_Error_Number,Command_Error_String);
}

/* =======================================
**  internal functions 
** ======================================= */
/**
 * This function is a wrapper to the PCO_GetErrorText routine imported from the PCO_errt_w.h.
 * This allows us to produce a descriptive string for the specified PCO error code.
 * @param pco_err The PCO error code to provide a descriptive string for.
 * @return A pointer to a string containing the descriptive string for the PCO error code. The
 *         string pointer to is always Command_PCO_Error_String.
 * @see #CCD_GENERAL_ERROR_STRING_LENGTH
 * @see #Command_PCO_Error_String
 */
static char *Command_PCO_Get_Error_Text(DWORD pco_err)
{
	PCO_GetErrorText(pco_err,Command_PCO_Error_String,CCD_GENERAL_ERROR_STRING_LENGTH);
	return Command_PCO_Error_String;
}

/**
 * Routine to convert the BCD (binary coded decimal) number to a normal integer.
 * @param x An unisgned char containing the BCD number (0..100). This is noamlly passed in a WORD, and we take
 *        the lower byte which contains the encoded number.
 * @return The decoded integer (0..100).
 */
static int Command_BCD_To_Decimal(unsigned char x)
{
    return x - 6 * (x >> 4);
}
